# Blinking the LED
## LED connection to MCU
According to the [Tiva C Launchpad User Guide][user-guide], the user buttons and RGB LED are connected to the following pins (where `PF` means Port F):

|GPIO Pin|Device|
|---|---|
|PF4|SW1|
|PF0|SW2|
|PF1|RGB LED (Red)|
|PF2|RGB LED (Blue)|
|PF3|RGB LED (Green)|

The GPIO ports' clock signals are disabled by default to save power and thus the ports themselves are disabled on startup. The *Run-Mode Clock Gating Control (RCGC)* is used to enable/disable a GPIO port, as mentioned in the [data sheet][datasheet]. In this case we want to enable Port F. This is done by setting the appropriate bit in the `RCGCGPIO` register. The bits in the register are used to enable/disable the GPIO clock signals as follows:

```
|...Bits [31:6] reserved...|R5|R4|R3|R2|R1|R0|
                             |  |  |  |  |  |
                             |  |  |  |  |  +-- Enable/disable GPIO port A clock
                             |  |  |  |  +----- Enable/disable GPIO port B clock
                             |  |  |  +-------- Enable/disable GPIO port C clock
                             |  |  +----------- Enable/disable GPIO port D clock
                             |  +-------------- Enable/disable GPIO port E clock
                             +----------------- Enable/disable GPIO port F clock
```

Once this is complete, the LED pin needs to be set output mode in the `GPIODIR` register and the bit for the pin needs to be set in the `GPIODATA` to set the voltage high. Finally, since the pin starts of in a tristate (undriven) mode, its digital function needs to be enabled with the `GPIODEN` register. With all of these pieces put together the LED will turn on.

## Troubleshooting
When first trying to run the code to light up the LED on the board, nothing happened. `gdb` did not start the program in `main.c` as it did in the previous example. Instead, the program counter is stuck at address 0x00000000:
```
$ arm-none-eabi-gdb -ex "target extended-remote :3333" firmware.elf
Reading symbols from firmware.elf...
Remote debugging using :3333
0x00000000 in tab ()
(gdb) info registers
r0             0x20000000          536870912
r1             0x31c               796
r2             0x400fe000          1074782208
r3             0x40004000          1073758208
r4             0x0                 0
r5             0x0                 0
r6             0x0                 0
r7             0x0                 0
r8             0x0                 0
r9             0x0                 0
r10            0x0                 0
r11            0x0                 0
r12            0x0                 0
sp             0x20007fd8          0x20007fd8
lr             0xfffffff9          -7
pc             0x0                 0x0 <tab>
xPSR           0x60000003          1610612739
fpscr          0x0                 0
msp            0x20007fd8          0x20007fd8
psp            0x0                 0x0 <tab>
primask        0x0                 0
basepri        0x0                 0
faultmask      0x0                 0
control        0x0                 0
```

Inspecting the hard fault status register (`HFAULTSTAT`), which is located at offset `0xD2C` from `0xE000E000` according to the [data sheet][datasheet], gives the following:
```
(gdb) x 0xE000E000 + 0xD2C
0xe000ed2c:     0x40000000
```

Registers are arranged in memory in little-endian format, meaning this register stored as follows:
```
Register data MSB to LSB: |B3|B2|B1|B0|

Storage in memory:
            |..|
Address A+0 |B0|
Address A+1 |B1|
Address A+2 |B2|
Address A+3 |B3|
            |..|
```

but `gdb` knows the target is little-endian and is kind to us - `0x40000000` is the value of the register (MSB to LSB). However, we can see the endianness of the data storage like so:
```
(gdb) x/4b 0xE000E000 + 0xD2C
0xe000ed2c:     0x00    0x00    0x00    0x40
```

Anyway, the data sheet page describing the `HFAULTSTAT` register says that this means a *forced hard fault* occurred:
> A forced hard fault has been generated by escalation of a fault with configurable priority that cannot be handled, either because of priority or because it is disabled. When this bit is set, the hard fault handler must read the other fault status registers to find the cause of the fault.

Examining the `FAULTSTAT` register we find:
```
(gdb) x/t 0xE000E000 +  0xD28
0xe000ed28:     00000000000000101000001000000000
```

Bits 9, 15 and 17 are set. Bit 9 means a *Precise Data Bus Error* occurred. Examining the `FAULTADDR` register shows that error happened at address `0x40025400`:
```
(gdb) x/x 0xE000E000 + 0xD38
0xe000ed38:     0x40025400
```

Address `0x40025400` is the `GPIODIR` register for Port F.

Bit 15 of the `FAULTSTAT` register means the `FAULTADDR` register we just checked is holding a valid bus fault address. Bit 17 of the `FAULTSTAT` register indicates that an *Invalid State Usage Fault* has occurred and that:
> The processor has attempted to execute an instruction that makes illegal use of the EPSR register. When this bit is set, the PC value stacked for the exception return points to the instruction that attempted the illegal use of the Execution Program Status Register (EPSR) register.

Using ChatGPT to dig into what this means, it turns out the PC counter value that caused the exception is stored on the stack as part of the exception handler entry sequence (so that it can return to it later once the exception has been handled). This means that the address of the instruction that caused exception can be found by inspecting the stack frame using `info frame` in `gdb`:
```
(gdb) info frame
Stack level 0, frame at 0x20007fe0:
 pc = 0x0 in tab; saved pc = <not saved>
 Outermost frame: outermost
 Arglist at 0x20007fe0, args:
 Locals at 0x20007fe0, Previous frame's sp is 0x20007fe0
```

### Debugging a program that fails immediately
By default, `OpenOCD`'s `reset` command resets the MCU and then runs it again immediately. Use the `reset halt` command to force the target to wait after resetting.
```
$ arm-none-eabi-gdb -ex "target extended-remote :3333" firmware.elf
Reading symbols from firmware.elf...
Remote debugging using :3333
0x00000000 in tab ()
(gdb) monitor reset halt
SRST error
[tm4c123gh6pm.cpu] halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x000002b4 msp: 0x20008000
(gdb)
```

### So, what's going on here?
After a lot of stepping through the code and examining the register values, I fixed the following issues:
- The base `RCGC` register memory address was wrong. I had to change `0x400FE000` to `0x400FE600`. This is what was causing the data bus issue above. Trying to use the `GPIODIR` register for a GPIO module that doesn't have a clock signal is not allowed. The [data sheet][datasheet] spells this out:
  > The RCGCGPIO register provides software the capability to enable and disable GPIO modules in Run mode. When enabled, a module is provided a clock and accesses to module registers are allowed. When disabled, the clock is disabled to save power and accesses to module registers generate a bus fault.
- The `gpio_set_pin` function had the wrong value for the `mask` variable. Adding an offset `Y` to a `uint32_t *` type causes the address offset to increase by `4Y`. This is obvious now, since a `uint32_t` is 4 bytes in size. 
- I discovered by looking at another Tiva C Launchpad project that I needed to enable the LED output pin's digital function with the `GPIODEN` register, otherwise the pin will be in an undriven state and the LED will not light up.

## Conclusion
This exercise largely served as a crash course in low-level debugging. I have an appreciation for TivaWare and other drivers to do some of this heavy lifting and help prevent me from shooting myself in the foot. Once I get past these low-level exercises, I will use them unapologetically.

[user-guide]: /docs/tiva-c-launchpad-user-guide.pdf "Tiva C Launchpad User Guide"
[datasheet]: /docs/tm4c123gh6pm-datasheet.pdf "TM4C123GH6PM Data Sheet"
